#ifndef Curve_H
#define Curve_H

#include <utility>
#include <functional>
#include <cmath>
#include <string>  
#include "Point.h"
#include "Vector.h"
const double PI = 3.141592653589793238463;

// абстрактрый базовый класс двумерной параметрически заданной кривой,
// в котором реализованы численные методы для работы с геометрическими кривыми:
// - вычисление точки кривой для заданного параметра;
// - вычисление первой и второй производных кривой для заданного параметра;
// - выдача информации об области определения параметра кривой;
// - вычисление длины кривой численным методом;
// - определение проекции точки на кривую численным методом.
 
class Curve
{
	
protected:
	
	// начальное и конечное значение параметра
	double t_begin;
	double t_end;

public:
		// конструктор класса
		Curve(double t_begin_ = 0, double t_end_ = 1):
			t_begin(t_begin_), t_end(t_end_)
		{
		};

		// вычисление точки кривой, соответствующей заданному параметру t
		virtual Point get_point(double t) = 0;

		// Возврат локальной системы координат в точке, соответствующей параметру t.
		// Локальная система координат задается вектором нормали и касательной к кривой в данной точке.
		virtual std::pair<Vector, Vector> get_local(double t);

		// выдача информации об области определения параметра кривой
		virtual std::pair<double, double> get_param();

		// вычисление первой производной кривой в точке t с приращением конечной разности функции на шаг h
		virtual double get_first_derivative(double t,  double h = 1e-6);

		// вычисление второй производной кривой в точке t с приращением конечной разности функции на шаг h
		virtual double get_second_derivative(double t, double h = 1e-5);

		// вычисление длины кривой по области определения параметра t от t_begin до t_end
		// с точность eps и шагом h при вычислении конечной разности функции
		virtual double get_length(double eps = 1e-6,   double h = 1e-6);

		// Вычисление проекции точки P на кривую с точнотью eps с помощью варьирования
		// параметра t от от t_begin до t_end с шагом h.
		// Параметр кривой t0, при котором нормаль к кривой в точке, соответствующий данному t0,
		// проходит через заданную точку P(p1,p2), может быть найден как решение уравнения:
		// 0 = (p1 - x(t0))*x'(t0) + (p2 - y(t0))*y'(t0), где x=x(t), y=y(t) - функции, задающие параметрически кривую.
		// При этом коэффециент -x'(t0)/y'(t0) является коэффициентом нормали к кривой в точке t0, а 
		// коэффициент  (p2 - y(t0))/(p1 - x(t0)) - коэффициентом наколона прямой, проходящей через точку P(p1,p2) и точку
		// кривой, соответствующей параметру t0.
		// Точка может иметь несколько проекций на кривую (например, проекция на окружность точки (0,0)). В этом случае
		// метод находт первую проекцию.
		virtual double get_projection(Point P, double eps = 1e-4, double h = 1e-5);

		// метод, возвращающий наименование кривой.
		virtual std::string get_name();
		
private:

	// вспомогательные методы

	// метод вычисления интеграла методом симпсона на сетке из n узлов с шагом h при вычислении конечной разности функции 
	double Integrate_curve(unsigned long long n, double h = 1e-6);

	// метод вычисления первой производной функции одной переменной
	std::pair<double, double> first_derivative(double t, double eps = 1e-6);

	// метод вычисления второй производной функции одной переменной
	std::pair<double, double> second_derivative(double t, double eps = 1e-6);

	// метод вычисления угла визирования из точки P на точку кривой, соответсвующей параметру t
	double SightAngle(double t, Point P);

	// метод вычисления разности между уголом визирования из точки P на точку кривой, соответсвующей параметру t,
	// и нормалью кривой в точке t
	double ScanFunction(double t, Point P, double h = 1e-6);
	
	// вычисление производной функции ScanFunction, соответсвующей точке кривой t и точки визирования P
	//double derivative_ScanFunction(double t, Point P, double h = 1e-6);
	
};

#endif
